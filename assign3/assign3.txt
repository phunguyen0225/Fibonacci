Assign3: Due 11:59PM CT April 1

***Please review the top part of ../hw1/hw1.txt***
***Your chance of success greatly increases if you start very early. Your chance of failure increases if you start late. Please use as many reviews as you possibly can.***

The Fibonacci series of numbers start with 1, 1, 2, 3, 5, 8, 13, 21, ...
where values at position 0 and 1 are 1, and values at each position after
that are a sum of values at the previous two positions.

Write four implementations of a function to compute the Fibonacci number at a given position.

Please start with one implementation at a time rather than rushing through all
of them at the same time.

The four implementations are described below:

1. An imperative iteration. 
  Given a position n, loop through totaling values until you reach the value for the given position.

2. A functional iteration. 
	  Given a position n, loop through totaling values until you reach the value for the given position. Avoid explicit mutability.

3. A simple recursion.
  Given a position, compute the value at a position using the expression fib(n - 1) + fib(n - 2).

4. A memoized recursion.
  Given a position, look up to see if the value has been precomputed and if so return that value. Otherwise, use recursion to compute the value.
  
Confirm that the memoized version is faster than the recursive version.

Reuse as much code as possible.

Please bring forward the practices, techniques, and tools you have learned so far. This includes: 
Good code quality
Lightweight design
Minimum code
Automated testing                                                         
Code coverage
Continuous integration

Once you complete coding, please answer the following:

1. What design principles did you use in this assignment? Discuss.

There are many principle that we applied during this project a few of them being the DRY principle and SRP principle.

We apply the DRY principle to help reduce our code and effort mainly in the test folder. The DRY principle help us write one single class to hold test cases for every function we test, instead of writing the same test cases in every single class that we create. This help us reduce our code and prevent copying and pasting everytime we create a function to test the test cases. This also raise the abstraction of the test, we create a interface that hold test cases and every class that want to test the test cases will just have to implements and return the function for that particular class.

Following the DRY principle, we also follow the SRP principle. The SRP principle help us separate our code into different classes, and each class serve one specific function for it. Following this principle can help easy of code change, readability and understandability. The SRP principle also help us raise the abstraction of Fibonacci into an interface. Separating each class when they implements the Fibonacci interface method.



2. Any surprises or things that you did not expect?

One of the thing that surprises us is that we can separate fast test with slow test into two different test cases and that we can override the function not to return that particular test. Also the use of "super" in the FibonacciMemoizedRecursion to call the Base class method instead of writting the Simple Recursion algorithm again to help solve our problem. This help us not only write cleaner and understandable code but also not violating the DRY principle as well.

